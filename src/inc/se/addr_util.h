#ifndef SE_ADDR_UTIL_H
#define SE_ADDR_UTIL_H

#include "addr.h"
#include "reinterpret_cast.h"

/**
 * @def se_addr_to_ptr
 * @brief Преобразует адрес в указатель заданного типа.
 *
 * Этот макрос принимает адрес и возвращает указатель на значение
 * заданного типа. Он позволяет безопасно преобразовывать адреса
 * в соответствующие указатели.
 *
 * @param T Тип, к которому следует привести адрес.
 * @param addr Адрес, который необходимо преобразовать в указатель.
 *
 * @return Указатель на значение типа `T`,
 *         соответствующее указанному адресу.
 */
#define se_addr_to_ptr(T, addr) se_reinterpret_cast(T *, addr)

/**
 * @def se_addr_from_ptr
 * @brief Преобразует указатель в адрес.
 *
 * Этот макрос принимает указатель и возвращает его значение
 * в виде целого числа (адреса) типа `se_uaddr_t`.
 * Он позволяет легко работать с адресами в виде целых чисел.
 *
 * @param ptr Указатель, который необходимо преобразовать в адрес.
 * @return Адрес, соответствующий указанному указателю в виде
 *         значения типа `se_uaddr_t`.
 */
#define se_addr_from_ptr(ptr) se_reinterpret_cast(se_uaddr_t, ptr)

/**
 * @def se_addr_diff
 * @brief Вычисляет разницу между двумя адресами.
 *
 * Этот макрос используется для вычисления разницы между двумя указателями.
 * Он возвращает разницу между значениями указателей `addr1` и `addr2`,
 * что соответствует числу байт, которое нужно пройти, чтобы перейти
 * от одного адреса к другому.
 *
 * @param addr1 Первый указатель.
 * @param addr2 Второй указатель.
 *
 * @return Разница между адресами (тип зависит от архитектуры и компилятора).
 */
#define se_addr_diff(addr1, addr2) (addr1 - addr2)

/**
 * @def se_addr_is_aligned
 * @brief Проверяет, выровнен ли адрес на указанную границу.
 *
 * Этот макрос определяет, выровнен ли заданный адрес на указанную границу выравнивания,
 * которая должна быть степенью двойки (например, 16, 32, 64).
 *
 * Он выполняет побитовую операцию И с `(align - 1)`,
 * чтобы проверить, делится ли адрес на `align` без остатка.
 *
 * @param addr Адрес для проверки (обычно указатель или целочисленный адрес).
 * @param align Граница выравнивания (должна быть степенью двойки).
 *
 * @return `true`, если адрес выровнен на указанную границу, иначе `false`.
 *
 * @note Параметр `align` должен быть степенью двойки (например, 2, 4, 8, 16 и т.д.).
 *       Использование значения, не являющегося степенью двойки,
 *       может привести к некорректным результатам.
 *
 * @warning Этот макрос не проверяет, является ли `align` степенью двойки.
 *          Ответственность за корректность `align` лежит на вызывающей стороне.
 *
 * Пример использования:
 * @code
 * void *ptr = (void *)0x1000;
 * if (se_addr_is_aligned((uintptr_t)ptr, 16)) {
 *     // Адрес выровнен по границе 16 байт
 * }
 * @endcode
 */
#define se_addr_is_aligned(addr, align) ((addr & ((align) - 1)) == 0)

#endif // SE_ADDR_UTIL_H

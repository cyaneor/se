/**
 * @file numeric_limit.h
 * @brief Определяет макросы для работы с пределами числовых типов.
 *
 * Этот файл содержит макросы для определения минимальных и максимальных значений для
 * знаковых и беззнаковых типов данных, таких как `sint8_t`, `uint16_t`, `sint128_t` и другие.
 * Макросы используют операции сдвига и инверсии для вычисления пределов и возвращают результаты
 * в соответствующих типах с использованием механизма приведения типов через `se_static_cast`.
 *
 * Макросы включают:
 * - `se_numeric_limit_sint_min(T)` — вычисляет минимальное значение для знакового типа `T`.
 * - `se_numeric_limit_sint_max(T)` — вычисляет максимальное значение для знакового типа `T`.
 * - `se_numeric_limit_uint_min(T)` — возвращает минимальное значение для беззнакового типа `T`.
 * - `se_numeric_limit_uint_max(T)` — вычисляет максимальное значение для беззнакового типа `T`.
 * - `se_numeric_limit_is_signed(T)` — проверяет, является ли тип `T` знаковым.
 *
 * Все макросы принимают параметр типа `T`, который должен быть одним
 * из поддерживаемых типов данных, и возвращают результат в том же типе.
 */

#ifndef SE_NUMERIC_LIMIT_H
#define SE_NUMERIC_LIMIT_H

#include "bit_util.h"
#include "static_cast.h"

/**
 * @def se_numeric_limit_sint_min(T)
 * @brief Определяет минимальное значение для знакового типа.
 *
 * Этот макрос вычисляет минимальное значение для знакового типа `T`, сдвигая единицу влево
 * на количество бит, равное размеру типа минус 1 (для учета знакового бита), и приводит результат
 * к типу `T` с помощью `se_static_cast`.
 *
 * @param T Тип данных, для которого вычисляется минимальное значение (например, `sint128_t`).
 * @return Минимальное значение для знакового типа `T`.
 */
#define se_numeric_limit_sint_min(T) (se_static_cast(T, se_bit_sign_type(T)))

/**
 * @def se_numeric_limit_sint_max(T)
 * @brief Определяет максимальное значение для знакового типа.
 *
 * Этот макрос вычисляет максимальное значение для знакового типа `T`, инвертируя минимальное
 * значение, полученное с помощью `se_numeric_limit_sint_min`.
 *
 * @param T Тип данных, для которого вычисляется максимальное значение (например, `sint128_t`).
 * @return Максимальное значение для знакового типа `T`.
 */
#define se_numeric_limit_sint_max(T) (~se_numeric_limit_sint_min(T))

/**
 * @def se_numeric_limit_uint_min(T)
 * @brief Определяет минимальное значение для беззнакового типа.
 *
 * Этот макрос возвращает минимальное значение для беззнакового типа `T`, которое всегда равно 0.
 * Результат приводится к типу `T` с помощью `se_static_cast`.
 *
 * @param T Тип данных, для которого вычисляется минимальное значение (например, `uint128_t`).
 * @return Минимальное значение для беззнакового типа `T` (всегда 0).
 */
#define se_numeric_limit_uint_min(T) (se_static_cast(T, 0))

/**
 * @def se_numeric_limit_uint_max(T)
 * @brief Определяет максимальное значение для беззнакового типа.
 *
 * Этот макрос вычисляет максимальное значение для беззнакового типа `T`, устанавливая все биты
 * в 1 (что эквивалентно значению -1 в знаковом представлении) и приводит результат к типу `T`
 * с помощью `se_static_cast`.
 *
 * @param T Тип данных, для которого вычисляется максимальное значение (например, `uint128_t`).
 * @return Максимальное значение для беззнакового типа `T`.
 */
#define se_numeric_limit_uint_max(T) (se_static_cast(T, -1))

/**
 * @def se_numeric_limit_is_signed(T)
 * @brief Проверяет, является ли тип знаковым.
 *
 * Этот макрос определяет, является ли тип `T` знаковым, сравнивая максимальное и минимальное
 * значения для беззнакового представления. Если максимальное значение меньше минимального,
 * тип считается знаковым.
 *
 * @param T Тип данных, для которого выполняется проверка (например, `sint128_t` или `uint128_t`).
 * @return Логическое значение: `true`, если тип знаковый, `false` — если беззнаковый.
 */
#define se_numeric_limit_is_signed(T) (se_numeric_limit_uint_max(T) < se_numeric_limit_uint_min(T))

#endif // SE_NUMERIC_LIMIT_H

#ifndef SE_MEMORY_STD_H
#define SE_MEMORY_STD_H

#include "size.h"
#include "attribute.h"

SE_COMPILER(EXTERN_C_BEGIN)

/**
 * @brief Оптимизированное копирование блока памяти.
 *
 * Функция копирует `n` байт из источника `src` в назначение `dst`,
 * используя оптимальные стратегии копирования в зависимости от:
 * - Размера блока
 * - Выравнивания указателей
 * - Доступных инструкций процессора (SSE2/AVX2/AVX512)
 *
 * @param dst Указатель на буфер назначения (должен быть валидным)
 * @param src Указатель на источник данных (должен быть валидным)
 * @param n Количество байт для копирования
 * @return Указатель на буфер назначения
 *
 * @note Выполняет проверки:
 *       - Указатели не NULL (SE_RUNTIME_ERROR_NULL_POINTER)
 *       - Нулевой размер копирования (возвращает dst без изменений)
 *
 * @note Стратегии копирования:
 *       1. Для маленьких (<64 байт) или невыровненных блоков:
 *          - 64-битные копии (8 байт) для блоков >= 8 байт
 *          - 32-битные копии (4 байта) для блоков >= 4 байт
 *          - Побайтовое копирование для остатка
 *
 *       2. Для больших выровненных блоков с поддержкой SIMD:
 *          - AVX512: 64-байтные векторы (при наличии SE_COMPILE_OPTION_AVX512)
 *          - AVX2: 32-байтные векторы (при наличии SE_COMPILE_OPTION_AVX2)
 *          - SSE2: 16-байтные векторы (при наличии SE_COMPILE_OPTION_SSE2)
 *          - Затем обработка остатка по той же схеме, что и для маленьких блоков
 */
SE_ATTRIBUTE(SYMBOL)
void *
se_memory_std_copy(void *dst, const void *src, se_usize_t n);

/**
 * @brief Оптимизированное обратное копирование блока памяти.
 *
 * Копирует `n` байт из источника `src` в назначение `dst` в обратном порядке,
 * начиная с конца блоков. Использует оптимальные стратегии копирования:
 * - Для маленьких или невыровненных блоков - поэтапное копирование
 * - Для больших выровненных блоков - векторные инструкции (SSE2/AVX2/AVX512)
 *
 * @param dst Указатель на начало буфера назначения
 * @param src Указатель на начало источника данных
 * @param n Количество байт для копирования
 * @return Указатель на начало скопированных данных в буфере назначения
 *
 * @note Особенности реализации:
 * - Выполняет проверку указателей (SE_RUNTIME_ERROR_NULL_POINTER)
 * - При n=0 возвращает dst без изменений
 * - Работает с перекрывающимися регионами памяти (подходит для memmove)
 *
 * @note Стратегии копирования:
 * 1. Для маленьких (<64 байт) или невыровненных блоков:
 *    - 64-битные операции (8 байт) для блоков ≥8 байт
 *    - 32-битные операции (4 байта) для блоков ≥4 байт
 *    - Побайтовое копирование для остатка
 *
 * 2. Для больших выровненных блоков:
 *    - AVX512: 64-байтные операции (при SE_COMPILE_OPTION_AVX512)
 *    - AVX2: 32-байтные операции (при SE_COMPILE_OPTION_AVX2)
 *    - SSE2: 16-байтные операции (при SE_COMPILE_OPTION_SSE2)
 *    - Затем обработка остатка по той же схеме
 *
 * @warning При перекрывающихся регионах src должен быть меньше dst,
 *          иначе возможно повреждение данных
 */
SE_ATTRIBUTE(SYMBOL)
void *
se_memory_std_copy_reverse(void *dst, const void *src, se_usize_t n);

/**
 * @brief Безопасное перемещение блока памяти с обработкой перекрывающихся регионов.
 *
 * Аналог стандартной функции memmove(). Копирует `n` байт из `src` в `dst`,
 * корректно обрабатывая случаи, когда регионы памяти перекрываются.
 *
 * @param dst Указатель на буфер назначения
 * @param src Указатель на источник данных
 * @param n Количество байт для перемещения
 * @return Указатель на буфер назначения
 *
 * @note Особенности реализации:
 * - Автоматически определяет перекрытие регионов памяти
 * - При перекрытии использует обратное копирование (se_memory_std_copy_reverse)
 * - Без перекрытия работает как прямое копирование (se_memory_std_copy)
 * - Гарантированно корректно работает с перекрывающимися регионами
 *
 * @note Преимущества перед стандартным memmove():
 * - Использует оптимизированные копирования с проверкой выравнивания
 * - Поддерживает векторные инструкции (SSE2/AVX2/AVX512)
 * - Имеет встроенные проверки безопасности
 *
 * @warning В отличие от se_memory_std_copy, всегда корректно обрабатывает
 *          случаи, когда dst находится внутри src..src+n
 */
SE_ATTRIBUTE(SYMBOL)
void *
se_memory_std_move(void *dst, const void *src, se_usize_t n);

/**
 * @brief Оптимизированное сравнение блоков памяти с определением позиции различия
 *
 * Сравнивает два блока памяти побайтово и возвращает указатель на первое различие.
 * Использует оптимальные стратегии сравнения в зависимости от размера блоков,
 * выравнивания и доступных SIMD-инструкций.
 *
 * @param lhs Указатель на первый блок памяти (должен быть валидным)
 * @param rhs Указатель на второй блок памяти (должен быть валидным)
 * @param n Размер сравниваемых блоков в байтах
 * @return Указатель на первое различие в lhs, либо nullptr если блоки идентичны
 *
 * @note Особенности реализации:
 * - Выполняет проверку указателей (SE_RUNTIME_ERROR_NULL_POINTER)
 * - При n=0 сразу возвращает nullptr (блоки считаются равными)
 * - Для маленьких (<64 байт) или невыровненных блоков:
 *   * 64-битное сравнение для блоков ≥8 байт
 *   * 32-битное сравнение для блоков ≥4 байт
 *   * Побайтовое сравнение для остатка
 * - Для больших выровненных блоков использует SIMD-инструкции:
 *   * AVX512 (64-байтные векторы) при SE_COMPILE_OPTION_AVX512
 *   * AVX2 (32-байтные векторы) при SE_COMPILE_OPTION_AVX2
 *   * SSE2 (16-байтные векторы) при SE_COMPILE_OPTION_SSE2
 * - Использует битовое сканирование для точного определения позиции различия
 *
 * @note В отличие от стандартного memcmp(), возвращает конкретный указатель
 *       на место первого различия, а не просто результат сравнения
 *
 * @warning Для корректной работы с SIMD-инструкциями требуется:
 *          - Правильное выравнивание указателей (16-байтное)
 *          - Достаточный размер блока памяти
 */
SE_ATTRIBUTE(SYMBOL)
const void *
se_memory_std_compare(const void *lhs, const void *rhs, se_usize_t n);

/**
 * @brief Обратное сравнение блоков памяти с поиском последнего различия
 *
 * Сравнивает два блока памяти с конца к началу и возвращает указатель
 * на последнее различие. Оптимизировано для различных размеров блоков
 * и поддерживает SIMD-инструкции.
 *
 * @param lhs Указатель на начало первого блока памяти
 * @param rhs Указатель на начало второго блока памяти
 * @param n Размер сравниваемых блоков в байтах
 * @return Указатель на последнее различие в lhs, либо nullptr если блоки идентичны
 *
 * @note Особенности реализации:
 * - Проверка указателей (SE_RUNTIME_ERROR_NULL_POINTER)
 * - При n=0 сразу возвращает nullptr
 * - Для маленьких (<64 байт) или невыровненных блоков:
 *   * Побайтовое сравнение с конца
 * - Для больших выровненных блоков:
 *   * AVX512 (64-байтные векторы) при SE_COMPILE_OPTION_AVX512
 *   * AVX2 (32-байтные векторы) при SE_COMPILE_OPTION_AVX2
 *   * SSE2 (16-байтные векторы) при SE_COMPILE_OPTION_SSE2
 * - Использует reverse битовое сканирование для точного определения позиции
 *
 * @note Отличия от se_memory_std_compare:
 * - Поиск ведется с конца блоков
 * - Возвращает указатель на последнее различие
 * - Оптимально для нахождения расхождений в конце данных
 *
 * @warning Для эффективной работы SIMD требуется:
 *          - 16-байтное выравнивание указателей
 *          - Размер блоков >= размеру векторных инструкций
 */
SE_ATTRIBUTE(SYMBOL)
const void *
se_memory_std_compare_reverse(const void *lhs, const void *rhs, se_usize_t n);

/**
 * @brief Оптимизированное заполнение памяти заданным значением
 *
 * Аналог стандартной функции memset() с дополнительными оптимизациями.
 * Заполняет блок памяти указанным байтовым значением, используя
 * оптимальные стратегии для разных размеров блоков и архитектур CPU.
 *
 * @param dst Указатель на начало блока памяти для заполнения
 * @param len Размер блока памяти в байтах
 * @param val Значение для заполнения (байт)
 * @return Указатель на начало заполненного блока памяти (dst)
 *
 * @note Особенности реализации:
 * - Проверка указателя dst (SE_RUNTIME_ERROR_NULL_POINTER)
 * - При len=0 сразу возвращает dst
 * - Для маленьких (<64 байт) или невыровненных блоков:
 *   * 64-битное заполнение для блоков ≥8 байт
 *   * 32-битное заполнение для блоков ≥4 байт
 *   * Побайтовое заполнение для остатка
 * - Для больших выровненных блоков использует SIMD-инструкции:
 *   * AVX512 (64-байтные векторы) при SE_COMPILE_OPTION_AVX512
 *   * AVX2 (32-байтные векторы) при SE_COMPILE_OPTION_AVX2
 *   * SSE2 (16-байтные векторы) при SE_COMPILE_OPTION_SSE2
 * - Оптимально работает с любым выравниванием указателя dst
 *
 * @note Преимущества перед стандартным memset():
 * - Автоматический выбор оптимальной стратегии заполнения
 * - Поддержка современных векторных инструкций
 * - Встроенные проверки безопасности
 * - Гарантированная работа с невыровненными указателями
 *
 * @warning Для максимальной производительности рекомендуется:
 *          - Использовать выровненные указатели (16-байтное выравнивание)
 *          - Работать с блоками памяти кратных 64 байтам
 */
SE_ATTRIBUTE(SYMBOL)
void *
se_memory_std_set(void *dst, se_usize_t len, se_u8_t val);

SE_COMPILER(EXTERN_C_END)

#endif // SE_MEMORY_STD_H

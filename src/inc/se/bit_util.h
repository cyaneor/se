#ifndef SE_BIT_UTIL_H
#define SE_BIT_UTIL_H

#include "compiler.h"
#include "numeric_util.h"
#include "type_util.h"

/**
 * @def se_bit_and
 * @brief Выполняет побитовое И между двумя значениями.
 *
 * Этот макрос реализует операцию побитового И (AND) между двумя входными значениями.
 * Используется для выполнения базовых побитовых операций, таких как проверка битов
 * или создание масок.
 *
 * @param x Первое значение (может быть любого числового типа).
 * @param y Второе значение (может быть любого числового типа).
 * @return Результат побитового И между x и y.
 *
 * Пример использования:
 * @code
 * int a = 5;  // 0101 в двоичной системе
 * int b = 3;  // 0011 в двоичной системе
 * int result = se_bit_and(a, b);
 * printf("Result: %d\n", result); // Вывод: "Result: 1" (0001 в двоичной системе)
 * @endcode
 */
#define se_bit_and(x, y) ((x) & (y))

/**
 * @def se_bit_is_pow2
 * @brief Проверяет, является ли значение степенью двойки.
 *
 * Этот макрос определяет, имеет ли входное значение только один установленный бит,
 * что эквивалентно проверке, является ли оно степенью двойки (например, 1, 2, 4, 8 и т.д.).
 *
 * @param x Значение, которое необходимо проверить (может быть любого числового типа).
 * @return 1 (true), если x является степенью двойки, иначе 0 (false).
 *
 * Пример использования:
 * @code
 * int value = 8; // 1000 в двоичной системе
 * if (se_bit_is_power_of_two(value)) {
 *     printf("Value is a power of two: %d\n", value); // Вывод: "Value is a power of two: 8"
 * }
 * @endcode
 */
#define se_bit_is_pow2(x) (se_bit_and((x), se_numeric_subtract_one(x)) == 0)

/**
 * @def se_bit_is_one
 * @brief Проверяет, является ли заданное значение единственным битом.
 *
 * Данный макрос определяет, установлен ли только один бит в заданном значении.
 * Если значение не равно нулю и имеет только один установленный бит,
 * макрос возвращает истинное значение (не ноль). В противном случае
 * возвращает ложное значение (ноль).
 *
 * @param x Значение, которое необходимо проверить (может быть любого числового типа).
 * @return 1 (true), если x является единственным битом, иначе 0 (false).
 *
 * Пример использования:
 * @code
 * int value = 4; // 0100 в двоичной системе
 * if (se_bit_is_single(value)) {
 *     printf("Value has a single bit: %d\n", value); // Вывод: "Value has a single bit: 4"
 * }
 * @endcode
 */
#define se_bit_is_one(x) (se_numeric_is_nonzero(x) && se_bit_is_pow2(x))

/**
 * @def se_bit_sign_type_pos(T)
 * @brief Определяет позицию знакового бита для типа T.
 *
 * @param T Знаковый целочисленный тип.
 * @return Позиция старшего (знакового) бита (нумерация с 0).
 *
 * Пример использования:
 * @code
 * int pos = se_bit_sign_type_pos(int); // Вернёт 31 для 32-битного int
 * @endcode
 */
#define se_bit_sign_type_pos(T) (se_type_bits(T) - 1)

/**
 * @def se_bit_sign_type(T)
 * @brief Вычисляет значение с установленным знаковым битом для типа T.
 *
 * @param T Знаковый целочисленный тип.
 * @return Значение, где только знаковый бит равен 1
 *         (например, 0x80000000 для 32-битного int).
 *
 * Пример использования:
 * @code
 * int val = se_bit_sign_type(int); // Вернёт 0x80000000 для 32-битного int
 *                                  // (интерпретируется как -2147483648)
 * @endcode
 */
#define se_bit_sign_type(T) ((T)1 << se_bit_sign_type_pos(T))

#if (SE_COMPILER_TYPE == SE_COMPILER_TYPE_GCC || SE_COMPILER_TYPE == SE_COMPILER_TYPE_CLANG)
/**
 * @def se_bit_scan_forward64
 * @brief Находит индекс первого установленного бита
 *        (младшего разряда) в 64-битной маске (GCC/Clang).
 *
 * Использует встроенную функцию компилятора `__builtin_ctzll`
 * для быстрого поиска индекса первого установленного бита в 64-битном числе.
 *
 * @param[out] index Указатель на переменную, в которую будет записан найденный индекс (0..63).
 * @param[in] mask 64-битная маска, в которой ищется установленный бит.
 *
 * @warning Если `mask` равен 0, поведение не определено.
 */
#    define se_bit_scan_forward64(index, mask) (*(index) = __builtin_ctzll(mask))

/**
 * @def se_bit_scan_reverse64
 * @brief Находит индекс последнего установленного бита
 *        (старшего разряда) в 64-битной маске (GCC/Clang).
 *
 * Использует встроенную функцию компилятора `__builtin_clzll`
 * для быстрого поиска индекса последнего установленного бита в 64-битном числе.
 *
 * @param[out] index Указатель на переменную, в которую будет записан найденный индекс (0..63).
 * @param[in] mask 64-битная маска, в которой ищется установленный бит.
 *
 * @note Если `mask` равен 0, поведение не определено.
 */
#    define se_bit_scan_reverse64(index, mask) (*(index) = 63 - __builtin_clzll(mask))

/**
 * @def se_bit_scan_forward32
 * @brief Находит индекс первого установленного бита
 *        (младшего разряда) в 32-битной маске (GCC/Clang).
 *
 * Использует встроенную функцию компилятора `__builtin_ctz`
 * для быстрого поиска индекса первого установленного бита в 32-битном числе.
 *
 * @param[out] index Указатель на переменную, в которую будет записан найденный индекс (0..31).
 * @param[in] mask 32-битная маска, в которой ищется установленный бит.
 *
 * @note Если `mask` равен 0, поведение не определено.
 */
#    define se_bit_scan_forward32(index, mask) (*(index) = __builtin_ctz(mask))

/**
 * @def se_bit_scan_reverse32
 * @brief Находит индекс последнего установленного бита
 *        (старшего разряда) в 32-битной маске (GCC/Clang).
 *
 * Использует встроенную функцию компилятора `__builtin_clz` для быстрого поиска
 * индекса последнего установленного бита в 32-битном числе.
 *
 * @param[out] index Указатель на переменную, в которую будет записан найденный индекс (0..31).
 * @param[in] mask 32-битная маска, в которой ищется установленный бит.
 *
 * @note Если `mask` равен 0, поведение не определено.
 */
#    define se_bit_scan_reverse32(index, mask) (*(index) = 31 - __builtin_clz(mask))
#elif (SE_COMPILER_TYPE == SE_COMPILER_TYPE_MSVC)

/**
 * @def se_bit_scan_forward64
 * @brief Находит индекс первого установленного бита
 *        (младшего разряда) в 64-битной маске (MSVC).
 *
 * Использует встроенную функцию MSVC `_BitScanForward64` для быстрого поиска
 * индекса первого установленного бита в 64-битном числе.
 *
 * @param[out] index Указатель на переменную, в которую будет записан найденный индекс (0..63).
 * @param[in] mask 64-битная маска, в которой ищется установленный бит.
 *
 * @note Если `mask` равен 0, функция возвращает 0,
 *       но это не означает, что бит 0 установлен.
 */
#    define se_bit_scan_forward64(index, mask) _BitScanForward64(index, mask)

/**
 * @def se_bit_scan_reverse64
 * @brief Находит индекс последнего установленного бита
 *        (старшего разряда) в 64-битной маске (MSVC).
 *
 * Использует встроенную функцию MSVC `_BitScanReverse64` для быстрого поиска
 * индекса последнего установленного бита в 64-битном числе.
 *
 * @param[out] index Указатель на переменную, в которую будет записан найденный индекс (0..63).
 * @param[in] mask 64-битная маска, в которой ищется установленный бит.
 *
 * @note Если `mask` равен 0, функция возвращает 0,
 *       но это не означает, что бит 0 установлен.
 */
#    define se_bit_scan_reverse64(index, mask) _BitScanReverse64(index, mask)

/**
 * @def se_bit_scan_forward32
 * @brief Находит индекс первого установленного бита
 *        (младшего разряда) в 32-битной маске (MSVC).
 *
 * Использует встроенную функцию MSVC `_BitScanForward` для быстрого поиска
 * индекса первого установленного бита в 32-битном числе.
 *
 * @param[out] index Указатель на переменную, в которую будет записан найденный индекс (0..31).
 * @param[in] mask 32-битная маска, в которой ищется установленный бит.
 *
 * @note Если `mask` равен 0, функция возвращает 0,
 *       но это не означает, что бит 0 установлен.
 */
#    define se_bit_scan_forward32(index, mask) _BitScanForward(index, mask)

/**
 * @def se_bit_scan_reverse32
 * @brief Находит индекс последнего установленного бита
 *        (старшего разряда) в 32-битной маске (MSVC).
 *
 * Использует встроенную функцию MSVC `_BitScanReverse` для быстрого поиска
 * индекса последнего установленного бита в 32-битном числе.
 *
 * @param[out] index Указатель на переменную, в которую будет записан найденный индекс (0..31).
 * @param[in] mask 32-битная маска, в которой ищется установленный бит.
 *
 * @note Если `mask` равен 0, функция возвращает 0,
 *       но это не означает, что бит 0 установлен.
 */
#    define se_bit_scan_reverse32(index, mask) _BitScanReverse(index, mask)
#else
#    pragma message("Warning: Compiler does not support bit scan function")
#endif

#endif // SE_BIT_UTIL_H
